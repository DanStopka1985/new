--Теперь напишем запрос по поиску индивида по СНИЛС


--получаем случайный идентификатор индивида
-- (просто получаем случайную строку из идентификаторов без привязки к типу идентификатора)
select code
from indiv_code
where id = (select (random() * max(id))::int from indiv_code);

--ищем полученный код среди имеющихся СНИЛС и достаем индивида
select coalesce(
               (select concat_ws(' ', sname, fname, mname)
                from indiv i
                where i.id = (select indiv_id
                              from indiv_code ic
                              where ic.code = '5998ddb21630dfa8ac748ff9d9f96775' and type_id = 1)),
               'indiv not found'
           );

/*
запрос выполняется ~100ms
Вроде бы быстро, но попробуем запустить его 200ми пользователями
    -выполнить App1
    -сгенерировать pgbadger (SHIFT+CTRL+B)
    -посмотреть top timeconsuming queries (ALT+CTRL+J ; CTRL+C ; SHIFT+CTRL+W)
        file:///C:/PostgreSQL/data/logs/pg11/a.html#time-consuming-queries
*/

/*
Для 200 условных пользователей общее время выполнения составляет уже около минуты
Для такого малого количества данных удалось получить уже серьезную нагрузку
Самый долгий запрос выполняется около минуты
*/

/*
Чтобы это ускорить, нужно понять, что именно долго работает.
Мы не знаем как Postgres выполняет запросы, каким способом получает данные, мы только говорим, что нужно получить, а как получить - не говорим.
Если вкратце в Postgres есть планировщик, который строит для запроса оптимальный алгоритм выполнения (План запроса).
И затем выполняет этот алгоритм и достает нужные данные. Увидеть этот алгоритм нам поможет explain
https://postgrespro.ru/docs/postgrespro/9.6/sql-explain
подробнее можно ознакомиться
explain представляет план запроса в виде дерева, каждый узел дерева - какое-то действие

Что из этого мы будем смотреть:

analyze - говорит о том, что запрос надо выполнить и замерить, что по факту было затрачено
verbose - вывести дополнительную информацию о выполнении узлов, вывод колонок,
            используемые триггеры, названия псевдонимов и схем
Buffers говорит об используемой памяти так же для каждого узла
формат по умолчанию текст, его мы и будем использовать
*/
--Выполним explain для нашего запроса поиска сначала без параметров.
explain--(verbose, analyse, buffers)
select coalesce(
               (select concat_ws(' ', sname, fname, mname)
                from indiv i
                where i.id = (select indiv_id
                              from indiv_code
                              where code = 'd0cd20f38f1c73cde6db4b8ce2fcffd6' and type_id = 1)),
               'indiv not found'
           );
SET max_parallel_workers_per_gather = 2;
/*
Узлы на нажних уровнях дерева (листьях) представляют собой первичные действия алгоритма - обычно это сканирование таблиц, индексов, констант.
Родительские узлы - следующие действия. И в корне получается результат выполнения запроса.
COST - стоимость – это относительная величина вычисляемая для выполняемого действия исходя из множества различных факторов,
    в частности настроек pg_settings, статистики, сложности стратегий и прочего. В общем случае чем меньше стоимость - тем быстрее выполняется запрос (но не всегда)
Первое число - стоимость запуска, второе - общая стоимость
В нашем случае сначала выполняется Parallel Seq Scan таблицы indiv_code - параллельное последовательное сканирование таблицы целиком c фильтрацией по искомому коду
и типу идентификатора.
Параллельное последовательное сканирование - это обычный seq scan выполняемый несколькими исполнителями параллельно, появилось в версии 9.6
Дальше идет сбор собранных данных (Gather).
Узел выше сканирует индекс pk_indiv по полученным данным из дочернего узла (Index Cond: (id = $1))
 (при создании первичного ключа, автоматически создается индекс)
Корневой узел возвращает результат запроса.
Теперь мы знаем как Postgres выполняет наш запрос и можем попытаться что-то изменить, чтобы его ускорить.
Сразу можем обратить внимание на то, что стоимость выполнения конечного узла и корневого не сильно отличается.
А так как стоимость корневого плана включает в себя стоимость всех его потомков -
 можно сделать вывод, что основную сложность алгоритма составляет конечный узел (parallel seq scan)
*/

/*Чтобы получить больше информации, выполним explain с параметрами (verbose, analyse, buffers)*/
explain(verbose, analyse, buffers)
select coalesce(
               (select concat_ws(' ', sname, fname, mname)
                from indiv i
                where i.id = (select indiv_id
                              from indiv_code
                              where code = 'd0cd20f38f1c73cde6db4b8ce2fcffd6' and type_id = 1)),
               'indiv not found'
           );
/*Здесь, кроме стоимости можно увидеть время выполнения каждого узла, какие данные узел возвращает и сколько памяти использует
Можно увидеть, что и по памяти конечный узел */















create index if not exists indiv_code_idx on indiv_code (code);


--просмотреть DDL создания индекса
select pg_get_indexdef('indiv_code_idx'::regclass);


--drop index indiv_code_hash_idx;
create index indiv_code_hash_idx on indiv_code using hash (code);



select pg_size_pretty(pg_table_size('indiv_code_hash_idx')) hash,
       pg_size_pretty(pg_table_size('indiv_code_idx'))      btree;
--drop index indiv_code_hash_idx;